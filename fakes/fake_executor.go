// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"os"
	"sync"

	"github.com/IBM/ubiquity/utils"
)

type FakeExecutor struct {
	EvalSymlinksStub        func(string) (string, error)
	evalSymlinksMutex       sync.RWMutex
	evalSymlinksArgsForCall []struct {
		arg1 string
	}
	evalSymlinksReturns struct {
		result1 string
		result2 error
	}
	evalSymlinksReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	ExecuteStub        func(string, []string) ([]byte, error)
	executeMutex       sync.RWMutex
	executeArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	executeReturns struct {
		result1 []byte
		result2 error
	}
	executeReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	ExecuteInteractiveStub        func(string, []string, []string) ([]byte, error)
	executeInteractiveMutex       sync.RWMutex
	executeInteractiveArgsForCall []struct {
		arg1 string
		arg2 []string
		arg3 []string
	}
	executeInteractiveReturns struct {
		result1 []byte
		result2 error
	}
	executeInteractiveReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	ExecuteWithTimeoutStub        func(int, string, []string) ([]byte, error)
	executeWithTimeoutMutex       sync.RWMutex
	executeWithTimeoutArgsForCall []struct {
		arg1 int
		arg2 string
		arg3 []string
	}
	executeWithTimeoutReturns struct {
		result1 []byte
		result2 error
	}
	executeWithTimeoutReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetDeviceForFileStatStub        func(os.FileInfo) uint64
	getDeviceForFileStatMutex       sync.RWMutex
	getDeviceForFileStatArgsForCall []struct {
		arg1 os.FileInfo
	}
	getDeviceForFileStatReturns struct {
		result1 uint64
	}
	getDeviceForFileStatReturnsOnCall map[int]struct {
		result1 uint64
	}
	GetGlobFilesStub        func(string) ([]string, error)
	getGlobFilesMutex       sync.RWMutex
	getGlobFilesArgsForCall []struct {
		arg1 string
	}
	getGlobFilesReturns struct {
		result1 []string
		result2 error
	}
	getGlobFilesReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	HostnameStub        func() (string, error)
	hostnameMutex       sync.RWMutex
	hostnameArgsForCall []struct {
	}
	hostnameReturns struct {
		result1 string
		result2 error
	}
	hostnameReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	IsDirStub        func(os.FileInfo) bool
	isDirMutex       sync.RWMutex
	isDirArgsForCall []struct {
		arg1 os.FileInfo
	}
	isDirReturns struct {
		result1 bool
	}
	isDirReturnsOnCall map[int]struct {
		result1 bool
	}
	IsDirEmptyStub        func(string) (bool, error)
	isDirEmptyMutex       sync.RWMutex
	isDirEmptyArgsForCall []struct {
		arg1 string
	}
	isDirEmptyReturns struct {
		result1 bool
		result2 error
	}
	isDirEmptyReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	IsExecutableStub        func(string) error
	isExecutableMutex       sync.RWMutex
	isExecutableArgsForCall []struct {
		arg1 string
	}
	isExecutableReturns struct {
		result1 error
	}
	isExecutableReturnsOnCall map[int]struct {
		result1 error
	}
	IsNotExistStub        func(error) bool
	isNotExistMutex       sync.RWMutex
	isNotExistArgsForCall []struct {
		arg1 error
	}
	isNotExistReturns struct {
		result1 bool
	}
	isNotExistReturnsOnCall map[int]struct {
		result1 bool
	}
	IsSameFileStub        func(os.FileInfo, os.FileInfo) bool
	isSameFileMutex       sync.RWMutex
	isSameFileArgsForCall []struct {
		arg1 os.FileInfo
		arg2 os.FileInfo
	}
	isSameFileReturns struct {
		result1 bool
	}
	isSameFileReturnsOnCall map[int]struct {
		result1 bool
	}
	IsSlinkStub        func(os.FileInfo) bool
	isSlinkMutex       sync.RWMutex
	isSlinkArgsForCall []struct {
		arg1 os.FileInfo
	}
	isSlinkReturns struct {
		result1 bool
	}
	isSlinkReturnsOnCall map[int]struct {
		result1 bool
	}
	LstatStub        func(string) (os.FileInfo, error)
	lstatMutex       sync.RWMutex
	lstatArgsForCall []struct {
		arg1 string
	}
	lstatReturns struct {
		result1 os.FileInfo
		result2 error
	}
	lstatReturnsOnCall map[int]struct {
		result1 os.FileInfo
		result2 error
	}
	MkdirStub        func(string, os.FileMode) error
	mkdirMutex       sync.RWMutex
	mkdirArgsForCall []struct {
		arg1 string
		arg2 os.FileMode
	}
	mkdirReturns struct {
		result1 error
	}
	mkdirReturnsOnCall map[int]struct {
		result1 error
	}
	MkdirAllStub        func(string, os.FileMode) error
	mkdirAllMutex       sync.RWMutex
	mkdirAllArgsForCall []struct {
		arg1 string
		arg2 os.FileMode
	}
	mkdirAllReturns struct {
		result1 error
	}
	mkdirAllReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveStub        func(string) error
	removeMutex       sync.RWMutex
	removeArgsForCall []struct {
		arg1 string
	}
	removeReturns struct {
		result1 error
	}
	removeReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveAllStub        func(string) error
	removeAllMutex       sync.RWMutex
	removeAllArgsForCall []struct {
		arg1 string
	}
	removeAllReturns struct {
		result1 error
	}
	removeAllReturnsOnCall map[int]struct {
		result1 error
	}
	StatStub        func(string) (os.FileInfo, error)
	statMutex       sync.RWMutex
	statArgsForCall []struct {
		arg1 string
	}
	statReturns struct {
		result1 os.FileInfo
		result2 error
	}
	statReturnsOnCall map[int]struct {
		result1 os.FileInfo
		result2 error
	}
	SymlinkStub        func(string, string) error
	symlinkMutex       sync.RWMutex
	symlinkArgsForCall []struct {
		arg1 string
		arg2 string
	}
	symlinkReturns struct {
		result1 error
	}
	symlinkReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeExecutor) EvalSymlinks(arg1 string) (string, error) {
	fake.evalSymlinksMutex.Lock()
	ret, specificReturn := fake.evalSymlinksReturnsOnCall[len(fake.evalSymlinksArgsForCall)]
	fake.evalSymlinksArgsForCall = append(fake.evalSymlinksArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("EvalSymlinks", []interface{}{arg1})
	fake.evalSymlinksMutex.Unlock()
	if fake.EvalSymlinksStub != nil {
		return fake.EvalSymlinksStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.evalSymlinksReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeExecutor) EvalSymlinksCallCount() int {
	fake.evalSymlinksMutex.RLock()
	defer fake.evalSymlinksMutex.RUnlock()
	return len(fake.evalSymlinksArgsForCall)
}

func (fake *FakeExecutor) EvalSymlinksCalls(stub func(string) (string, error)) {
	fake.evalSymlinksMutex.Lock()
	defer fake.evalSymlinksMutex.Unlock()
	fake.EvalSymlinksStub = stub
}

func (fake *FakeExecutor) EvalSymlinksArgsForCall(i int) string {
	fake.evalSymlinksMutex.RLock()
	defer fake.evalSymlinksMutex.RUnlock()
	argsForCall := fake.evalSymlinksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeExecutor) EvalSymlinksReturns(result1 string, result2 error) {
	fake.evalSymlinksMutex.Lock()
	defer fake.evalSymlinksMutex.Unlock()
	fake.EvalSymlinksStub = nil
	fake.evalSymlinksReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutor) EvalSymlinksReturnsOnCall(i int, result1 string, result2 error) {
	fake.evalSymlinksMutex.Lock()
	defer fake.evalSymlinksMutex.Unlock()
	fake.EvalSymlinksStub = nil
	if fake.evalSymlinksReturnsOnCall == nil {
		fake.evalSymlinksReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.evalSymlinksReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutor) Execute(arg1 string, arg2 []string) ([]byte, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.executeMutex.Lock()
	ret, specificReturn := fake.executeReturnsOnCall[len(fake.executeArgsForCall)]
	fake.executeArgsForCall = append(fake.executeArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2Copy})
	fake.recordInvocation("Execute", []interface{}{arg1, arg2Copy})
	fake.executeMutex.Unlock()
	if fake.ExecuteStub != nil {
		return fake.ExecuteStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.executeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeExecutor) ExecuteCallCount() int {
	fake.executeMutex.RLock()
	defer fake.executeMutex.RUnlock()
	return len(fake.executeArgsForCall)
}

func (fake *FakeExecutor) ExecuteCalls(stub func(string, []string) ([]byte, error)) {
	fake.executeMutex.Lock()
	defer fake.executeMutex.Unlock()
	fake.ExecuteStub = stub
}

func (fake *FakeExecutor) ExecuteArgsForCall(i int) (string, []string) {
	fake.executeMutex.RLock()
	defer fake.executeMutex.RUnlock()
	argsForCall := fake.executeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeExecutor) ExecuteReturns(result1 []byte, result2 error) {
	fake.executeMutex.Lock()
	defer fake.executeMutex.Unlock()
	fake.ExecuteStub = nil
	fake.executeReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutor) ExecuteReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.executeMutex.Lock()
	defer fake.executeMutex.Unlock()
	fake.ExecuteStub = nil
	if fake.executeReturnsOnCall == nil {
		fake.executeReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.executeReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutor) ExecuteInteractive(arg1 string, arg2 []string, arg3 []string) ([]byte, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.executeInteractiveMutex.Lock()
	ret, specificReturn := fake.executeInteractiveReturnsOnCall[len(fake.executeInteractiveArgsForCall)]
	fake.executeInteractiveArgsForCall = append(fake.executeInteractiveArgsForCall, struct {
		arg1 string
		arg2 []string
		arg3 []string
	}{arg1, arg2Copy, arg3Copy})
	fake.recordInvocation("ExecuteInteractive", []interface{}{arg1, arg2Copy, arg3Copy})
	fake.executeInteractiveMutex.Unlock()
	if fake.ExecuteInteractiveStub != nil {
		return fake.ExecuteInteractiveStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.executeInteractiveReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeExecutor) ExecuteInteractiveCallCount() int {
	fake.executeInteractiveMutex.RLock()
	defer fake.executeInteractiveMutex.RUnlock()
	return len(fake.executeInteractiveArgsForCall)
}

func (fake *FakeExecutor) ExecuteInteractiveCalls(stub func(string, []string, []string) ([]byte, error)) {
	fake.executeInteractiveMutex.Lock()
	defer fake.executeInteractiveMutex.Unlock()
	fake.ExecuteInteractiveStub = stub
}

func (fake *FakeExecutor) ExecuteInteractiveArgsForCall(i int) (string, []string, []string) {
	fake.executeInteractiveMutex.RLock()
	defer fake.executeInteractiveMutex.RUnlock()
	argsForCall := fake.executeInteractiveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeExecutor) ExecuteInteractiveReturns(result1 []byte, result2 error) {
	fake.executeInteractiveMutex.Lock()
	defer fake.executeInteractiveMutex.Unlock()
	fake.ExecuteInteractiveStub = nil
	fake.executeInteractiveReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutor) ExecuteInteractiveReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.executeInteractiveMutex.Lock()
	defer fake.executeInteractiveMutex.Unlock()
	fake.ExecuteInteractiveStub = nil
	if fake.executeInteractiveReturnsOnCall == nil {
		fake.executeInteractiveReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.executeInteractiveReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutor) ExecuteWithTimeout(arg1 int, arg2 string, arg3 []string) ([]byte, error) {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.executeWithTimeoutMutex.Lock()
	ret, specificReturn := fake.executeWithTimeoutReturnsOnCall[len(fake.executeWithTimeoutArgsForCall)]
	fake.executeWithTimeoutArgsForCall = append(fake.executeWithTimeoutArgsForCall, struct {
		arg1 int
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3Copy})
	fake.recordInvocation("ExecuteWithTimeout", []interface{}{arg1, arg2, arg3Copy})
	fake.executeWithTimeoutMutex.Unlock()
	if fake.ExecuteWithTimeoutStub != nil {
		return fake.ExecuteWithTimeoutStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.executeWithTimeoutReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeExecutor) ExecuteWithTimeoutCallCount() int {
	fake.executeWithTimeoutMutex.RLock()
	defer fake.executeWithTimeoutMutex.RUnlock()
	return len(fake.executeWithTimeoutArgsForCall)
}

func (fake *FakeExecutor) ExecuteWithTimeoutCalls(stub func(int, string, []string) ([]byte, error)) {
	fake.executeWithTimeoutMutex.Lock()
	defer fake.executeWithTimeoutMutex.Unlock()
	fake.ExecuteWithTimeoutStub = stub
}

func (fake *FakeExecutor) ExecuteWithTimeoutArgsForCall(i int) (int, string, []string) {
	fake.executeWithTimeoutMutex.RLock()
	defer fake.executeWithTimeoutMutex.RUnlock()
	argsForCall := fake.executeWithTimeoutArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeExecutor) ExecuteWithTimeoutReturns(result1 []byte, result2 error) {
	fake.executeWithTimeoutMutex.Lock()
	defer fake.executeWithTimeoutMutex.Unlock()
	fake.ExecuteWithTimeoutStub = nil
	fake.executeWithTimeoutReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutor) ExecuteWithTimeoutReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.executeWithTimeoutMutex.Lock()
	defer fake.executeWithTimeoutMutex.Unlock()
	fake.ExecuteWithTimeoutStub = nil
	if fake.executeWithTimeoutReturnsOnCall == nil {
		fake.executeWithTimeoutReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.executeWithTimeoutReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutor) GetDeviceForFileStat(arg1 os.FileInfo) uint64 {
	fake.getDeviceForFileStatMutex.Lock()
	ret, specificReturn := fake.getDeviceForFileStatReturnsOnCall[len(fake.getDeviceForFileStatArgsForCall)]
	fake.getDeviceForFileStatArgsForCall = append(fake.getDeviceForFileStatArgsForCall, struct {
		arg1 os.FileInfo
	}{arg1})
	fake.recordInvocation("GetDeviceForFileStat", []interface{}{arg1})
	fake.getDeviceForFileStatMutex.Unlock()
	if fake.GetDeviceForFileStatStub != nil {
		return fake.GetDeviceForFileStatStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getDeviceForFileStatReturns
	return fakeReturns.result1
}

func (fake *FakeExecutor) GetDeviceForFileStatCallCount() int {
	fake.getDeviceForFileStatMutex.RLock()
	defer fake.getDeviceForFileStatMutex.RUnlock()
	return len(fake.getDeviceForFileStatArgsForCall)
}

func (fake *FakeExecutor) GetDeviceForFileStatCalls(stub func(os.FileInfo) uint64) {
	fake.getDeviceForFileStatMutex.Lock()
	defer fake.getDeviceForFileStatMutex.Unlock()
	fake.GetDeviceForFileStatStub = stub
}

func (fake *FakeExecutor) GetDeviceForFileStatArgsForCall(i int) os.FileInfo {
	fake.getDeviceForFileStatMutex.RLock()
	defer fake.getDeviceForFileStatMutex.RUnlock()
	argsForCall := fake.getDeviceForFileStatArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeExecutor) GetDeviceForFileStatReturns(result1 uint64) {
	fake.getDeviceForFileStatMutex.Lock()
	defer fake.getDeviceForFileStatMutex.Unlock()
	fake.GetDeviceForFileStatStub = nil
	fake.getDeviceForFileStatReturns = struct {
		result1 uint64
	}{result1}
}

func (fake *FakeExecutor) GetDeviceForFileStatReturnsOnCall(i int, result1 uint64) {
	fake.getDeviceForFileStatMutex.Lock()
	defer fake.getDeviceForFileStatMutex.Unlock()
	fake.GetDeviceForFileStatStub = nil
	if fake.getDeviceForFileStatReturnsOnCall == nil {
		fake.getDeviceForFileStatReturnsOnCall = make(map[int]struct {
			result1 uint64
		})
	}
	fake.getDeviceForFileStatReturnsOnCall[i] = struct {
		result1 uint64
	}{result1}
}

func (fake *FakeExecutor) GetGlobFiles(arg1 string) ([]string, error) {
	fake.getGlobFilesMutex.Lock()
	ret, specificReturn := fake.getGlobFilesReturnsOnCall[len(fake.getGlobFilesArgsForCall)]
	fake.getGlobFilesArgsForCall = append(fake.getGlobFilesArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetGlobFiles", []interface{}{arg1})
	fake.getGlobFilesMutex.Unlock()
	if fake.GetGlobFilesStub != nil {
		return fake.GetGlobFilesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getGlobFilesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeExecutor) GetGlobFilesCallCount() int {
	fake.getGlobFilesMutex.RLock()
	defer fake.getGlobFilesMutex.RUnlock()
	return len(fake.getGlobFilesArgsForCall)
}

func (fake *FakeExecutor) GetGlobFilesCalls(stub func(string) ([]string, error)) {
	fake.getGlobFilesMutex.Lock()
	defer fake.getGlobFilesMutex.Unlock()
	fake.GetGlobFilesStub = stub
}

func (fake *FakeExecutor) GetGlobFilesArgsForCall(i int) string {
	fake.getGlobFilesMutex.RLock()
	defer fake.getGlobFilesMutex.RUnlock()
	argsForCall := fake.getGlobFilesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeExecutor) GetGlobFilesReturns(result1 []string, result2 error) {
	fake.getGlobFilesMutex.Lock()
	defer fake.getGlobFilesMutex.Unlock()
	fake.GetGlobFilesStub = nil
	fake.getGlobFilesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutor) GetGlobFilesReturnsOnCall(i int, result1 []string, result2 error) {
	fake.getGlobFilesMutex.Lock()
	defer fake.getGlobFilesMutex.Unlock()
	fake.GetGlobFilesStub = nil
	if fake.getGlobFilesReturnsOnCall == nil {
		fake.getGlobFilesReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getGlobFilesReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutor) Hostname() (string, error) {
	fake.hostnameMutex.Lock()
	ret, specificReturn := fake.hostnameReturnsOnCall[len(fake.hostnameArgsForCall)]
	fake.hostnameArgsForCall = append(fake.hostnameArgsForCall, struct {
	}{})
	fake.recordInvocation("Hostname", []interface{}{})
	fake.hostnameMutex.Unlock()
	if fake.HostnameStub != nil {
		return fake.HostnameStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.hostnameReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeExecutor) HostnameCallCount() int {
	fake.hostnameMutex.RLock()
	defer fake.hostnameMutex.RUnlock()
	return len(fake.hostnameArgsForCall)
}

func (fake *FakeExecutor) HostnameCalls(stub func() (string, error)) {
	fake.hostnameMutex.Lock()
	defer fake.hostnameMutex.Unlock()
	fake.HostnameStub = stub
}

func (fake *FakeExecutor) HostnameReturns(result1 string, result2 error) {
	fake.hostnameMutex.Lock()
	defer fake.hostnameMutex.Unlock()
	fake.HostnameStub = nil
	fake.hostnameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutor) HostnameReturnsOnCall(i int, result1 string, result2 error) {
	fake.hostnameMutex.Lock()
	defer fake.hostnameMutex.Unlock()
	fake.HostnameStub = nil
	if fake.hostnameReturnsOnCall == nil {
		fake.hostnameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.hostnameReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutor) IsDir(arg1 os.FileInfo) bool {
	fake.isDirMutex.Lock()
	ret, specificReturn := fake.isDirReturnsOnCall[len(fake.isDirArgsForCall)]
	fake.isDirArgsForCall = append(fake.isDirArgsForCall, struct {
		arg1 os.FileInfo
	}{arg1})
	fake.recordInvocation("IsDir", []interface{}{arg1})
	fake.isDirMutex.Unlock()
	if fake.IsDirStub != nil {
		return fake.IsDirStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isDirReturns
	return fakeReturns.result1
}

func (fake *FakeExecutor) IsDirCallCount() int {
	fake.isDirMutex.RLock()
	defer fake.isDirMutex.RUnlock()
	return len(fake.isDirArgsForCall)
}

func (fake *FakeExecutor) IsDirCalls(stub func(os.FileInfo) bool) {
	fake.isDirMutex.Lock()
	defer fake.isDirMutex.Unlock()
	fake.IsDirStub = stub
}

func (fake *FakeExecutor) IsDirArgsForCall(i int) os.FileInfo {
	fake.isDirMutex.RLock()
	defer fake.isDirMutex.RUnlock()
	argsForCall := fake.isDirArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeExecutor) IsDirReturns(result1 bool) {
	fake.isDirMutex.Lock()
	defer fake.isDirMutex.Unlock()
	fake.IsDirStub = nil
	fake.isDirReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeExecutor) IsDirReturnsOnCall(i int, result1 bool) {
	fake.isDirMutex.Lock()
	defer fake.isDirMutex.Unlock()
	fake.IsDirStub = nil
	if fake.isDirReturnsOnCall == nil {
		fake.isDirReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isDirReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeExecutor) IsDirEmpty(arg1 string) (bool, error) {
	fake.isDirEmptyMutex.Lock()
	ret, specificReturn := fake.isDirEmptyReturnsOnCall[len(fake.isDirEmptyArgsForCall)]
	fake.isDirEmptyArgsForCall = append(fake.isDirEmptyArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("IsDirEmpty", []interface{}{arg1})
	fake.isDirEmptyMutex.Unlock()
	if fake.IsDirEmptyStub != nil {
		return fake.IsDirEmptyStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.isDirEmptyReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeExecutor) IsDirEmptyCallCount() int {
	fake.isDirEmptyMutex.RLock()
	defer fake.isDirEmptyMutex.RUnlock()
	return len(fake.isDirEmptyArgsForCall)
}

func (fake *FakeExecutor) IsDirEmptyCalls(stub func(string) (bool, error)) {
	fake.isDirEmptyMutex.Lock()
	defer fake.isDirEmptyMutex.Unlock()
	fake.IsDirEmptyStub = stub
}

func (fake *FakeExecutor) IsDirEmptyArgsForCall(i int) string {
	fake.isDirEmptyMutex.RLock()
	defer fake.isDirEmptyMutex.RUnlock()
	argsForCall := fake.isDirEmptyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeExecutor) IsDirEmptyReturns(result1 bool, result2 error) {
	fake.isDirEmptyMutex.Lock()
	defer fake.isDirEmptyMutex.Unlock()
	fake.IsDirEmptyStub = nil
	fake.isDirEmptyReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutor) IsDirEmptyReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isDirEmptyMutex.Lock()
	defer fake.isDirEmptyMutex.Unlock()
	fake.IsDirEmptyStub = nil
	if fake.isDirEmptyReturnsOnCall == nil {
		fake.isDirEmptyReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isDirEmptyReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutor) IsExecutable(arg1 string) error {
	fake.isExecutableMutex.Lock()
	ret, specificReturn := fake.isExecutableReturnsOnCall[len(fake.isExecutableArgsForCall)]
	fake.isExecutableArgsForCall = append(fake.isExecutableArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("IsExecutable", []interface{}{arg1})
	fake.isExecutableMutex.Unlock()
	if fake.IsExecutableStub != nil {
		return fake.IsExecutableStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isExecutableReturns
	return fakeReturns.result1
}

func (fake *FakeExecutor) IsExecutableCallCount() int {
	fake.isExecutableMutex.RLock()
	defer fake.isExecutableMutex.RUnlock()
	return len(fake.isExecutableArgsForCall)
}

func (fake *FakeExecutor) IsExecutableCalls(stub func(string) error) {
	fake.isExecutableMutex.Lock()
	defer fake.isExecutableMutex.Unlock()
	fake.IsExecutableStub = stub
}

func (fake *FakeExecutor) IsExecutableArgsForCall(i int) string {
	fake.isExecutableMutex.RLock()
	defer fake.isExecutableMutex.RUnlock()
	argsForCall := fake.isExecutableArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeExecutor) IsExecutableReturns(result1 error) {
	fake.isExecutableMutex.Lock()
	defer fake.isExecutableMutex.Unlock()
	fake.IsExecutableStub = nil
	fake.isExecutableReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutor) IsExecutableReturnsOnCall(i int, result1 error) {
	fake.isExecutableMutex.Lock()
	defer fake.isExecutableMutex.Unlock()
	fake.IsExecutableStub = nil
	if fake.isExecutableReturnsOnCall == nil {
		fake.isExecutableReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.isExecutableReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutor) IsNotExist(arg1 error) bool {
	fake.isNotExistMutex.Lock()
	ret, specificReturn := fake.isNotExistReturnsOnCall[len(fake.isNotExistArgsForCall)]
	fake.isNotExistArgsForCall = append(fake.isNotExistArgsForCall, struct {
		arg1 error
	}{arg1})
	fake.recordInvocation("IsNotExist", []interface{}{arg1})
	fake.isNotExistMutex.Unlock()
	if fake.IsNotExistStub != nil {
		return fake.IsNotExistStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isNotExistReturns
	return fakeReturns.result1
}

func (fake *FakeExecutor) IsNotExistCallCount() int {
	fake.isNotExistMutex.RLock()
	defer fake.isNotExistMutex.RUnlock()
	return len(fake.isNotExistArgsForCall)
}

func (fake *FakeExecutor) IsNotExistCalls(stub func(error) bool) {
	fake.isNotExistMutex.Lock()
	defer fake.isNotExistMutex.Unlock()
	fake.IsNotExistStub = stub
}

func (fake *FakeExecutor) IsNotExistArgsForCall(i int) error {
	fake.isNotExistMutex.RLock()
	defer fake.isNotExistMutex.RUnlock()
	argsForCall := fake.isNotExistArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeExecutor) IsNotExistReturns(result1 bool) {
	fake.isNotExistMutex.Lock()
	defer fake.isNotExistMutex.Unlock()
	fake.IsNotExistStub = nil
	fake.isNotExistReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeExecutor) IsNotExistReturnsOnCall(i int, result1 bool) {
	fake.isNotExistMutex.Lock()
	defer fake.isNotExistMutex.Unlock()
	fake.IsNotExistStub = nil
	if fake.isNotExistReturnsOnCall == nil {
		fake.isNotExistReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isNotExistReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeExecutor) IsSameFile(arg1 os.FileInfo, arg2 os.FileInfo) bool {
	fake.isSameFileMutex.Lock()
	ret, specificReturn := fake.isSameFileReturnsOnCall[len(fake.isSameFileArgsForCall)]
	fake.isSameFileArgsForCall = append(fake.isSameFileArgsForCall, struct {
		arg1 os.FileInfo
		arg2 os.FileInfo
	}{arg1, arg2})
	fake.recordInvocation("IsSameFile", []interface{}{arg1, arg2})
	fake.isSameFileMutex.Unlock()
	if fake.IsSameFileStub != nil {
		return fake.IsSameFileStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isSameFileReturns
	return fakeReturns.result1
}

func (fake *FakeExecutor) IsSameFileCallCount() int {
	fake.isSameFileMutex.RLock()
	defer fake.isSameFileMutex.RUnlock()
	return len(fake.isSameFileArgsForCall)
}

func (fake *FakeExecutor) IsSameFileCalls(stub func(os.FileInfo, os.FileInfo) bool) {
	fake.isSameFileMutex.Lock()
	defer fake.isSameFileMutex.Unlock()
	fake.IsSameFileStub = stub
}

func (fake *FakeExecutor) IsSameFileArgsForCall(i int) (os.FileInfo, os.FileInfo) {
	fake.isSameFileMutex.RLock()
	defer fake.isSameFileMutex.RUnlock()
	argsForCall := fake.isSameFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeExecutor) IsSameFileReturns(result1 bool) {
	fake.isSameFileMutex.Lock()
	defer fake.isSameFileMutex.Unlock()
	fake.IsSameFileStub = nil
	fake.isSameFileReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeExecutor) IsSameFileReturnsOnCall(i int, result1 bool) {
	fake.isSameFileMutex.Lock()
	defer fake.isSameFileMutex.Unlock()
	fake.IsSameFileStub = nil
	if fake.isSameFileReturnsOnCall == nil {
		fake.isSameFileReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isSameFileReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeExecutor) IsSlink(arg1 os.FileInfo) bool {
	fake.isSlinkMutex.Lock()
	ret, specificReturn := fake.isSlinkReturnsOnCall[len(fake.isSlinkArgsForCall)]
	fake.isSlinkArgsForCall = append(fake.isSlinkArgsForCall, struct {
		arg1 os.FileInfo
	}{arg1})
	fake.recordInvocation("IsSlink", []interface{}{arg1})
	fake.isSlinkMutex.Unlock()
	if fake.IsSlinkStub != nil {
		return fake.IsSlinkStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isSlinkReturns
	return fakeReturns.result1
}

func (fake *FakeExecutor) IsSlinkCallCount() int {
	fake.isSlinkMutex.RLock()
	defer fake.isSlinkMutex.RUnlock()
	return len(fake.isSlinkArgsForCall)
}

func (fake *FakeExecutor) IsSlinkCalls(stub func(os.FileInfo) bool) {
	fake.isSlinkMutex.Lock()
	defer fake.isSlinkMutex.Unlock()
	fake.IsSlinkStub = stub
}

func (fake *FakeExecutor) IsSlinkArgsForCall(i int) os.FileInfo {
	fake.isSlinkMutex.RLock()
	defer fake.isSlinkMutex.RUnlock()
	argsForCall := fake.isSlinkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeExecutor) IsSlinkReturns(result1 bool) {
	fake.isSlinkMutex.Lock()
	defer fake.isSlinkMutex.Unlock()
	fake.IsSlinkStub = nil
	fake.isSlinkReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeExecutor) IsSlinkReturnsOnCall(i int, result1 bool) {
	fake.isSlinkMutex.Lock()
	defer fake.isSlinkMutex.Unlock()
	fake.IsSlinkStub = nil
	if fake.isSlinkReturnsOnCall == nil {
		fake.isSlinkReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isSlinkReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeExecutor) Lstat(arg1 string) (os.FileInfo, error) {
	fake.lstatMutex.Lock()
	ret, specificReturn := fake.lstatReturnsOnCall[len(fake.lstatArgsForCall)]
	fake.lstatArgsForCall = append(fake.lstatArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Lstat", []interface{}{arg1})
	fake.lstatMutex.Unlock()
	if fake.LstatStub != nil {
		return fake.LstatStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.lstatReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeExecutor) LstatCallCount() int {
	fake.lstatMutex.RLock()
	defer fake.lstatMutex.RUnlock()
	return len(fake.lstatArgsForCall)
}

func (fake *FakeExecutor) LstatCalls(stub func(string) (os.FileInfo, error)) {
	fake.lstatMutex.Lock()
	defer fake.lstatMutex.Unlock()
	fake.LstatStub = stub
}

func (fake *FakeExecutor) LstatArgsForCall(i int) string {
	fake.lstatMutex.RLock()
	defer fake.lstatMutex.RUnlock()
	argsForCall := fake.lstatArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeExecutor) LstatReturns(result1 os.FileInfo, result2 error) {
	fake.lstatMutex.Lock()
	defer fake.lstatMutex.Unlock()
	fake.LstatStub = nil
	fake.lstatReturns = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutor) LstatReturnsOnCall(i int, result1 os.FileInfo, result2 error) {
	fake.lstatMutex.Lock()
	defer fake.lstatMutex.Unlock()
	fake.LstatStub = nil
	if fake.lstatReturnsOnCall == nil {
		fake.lstatReturnsOnCall = make(map[int]struct {
			result1 os.FileInfo
			result2 error
		})
	}
	fake.lstatReturnsOnCall[i] = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutor) Mkdir(arg1 string, arg2 os.FileMode) error {
	fake.mkdirMutex.Lock()
	ret, specificReturn := fake.mkdirReturnsOnCall[len(fake.mkdirArgsForCall)]
	fake.mkdirArgsForCall = append(fake.mkdirArgsForCall, struct {
		arg1 string
		arg2 os.FileMode
	}{arg1, arg2})
	fake.recordInvocation("Mkdir", []interface{}{arg1, arg2})
	fake.mkdirMutex.Unlock()
	if fake.MkdirStub != nil {
		return fake.MkdirStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.mkdirReturns
	return fakeReturns.result1
}

func (fake *FakeExecutor) MkdirCallCount() int {
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	return len(fake.mkdirArgsForCall)
}

func (fake *FakeExecutor) MkdirCalls(stub func(string, os.FileMode) error) {
	fake.mkdirMutex.Lock()
	defer fake.mkdirMutex.Unlock()
	fake.MkdirStub = stub
}

func (fake *FakeExecutor) MkdirArgsForCall(i int) (string, os.FileMode) {
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	argsForCall := fake.mkdirArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeExecutor) MkdirReturns(result1 error) {
	fake.mkdirMutex.Lock()
	defer fake.mkdirMutex.Unlock()
	fake.MkdirStub = nil
	fake.mkdirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutor) MkdirReturnsOnCall(i int, result1 error) {
	fake.mkdirMutex.Lock()
	defer fake.mkdirMutex.Unlock()
	fake.MkdirStub = nil
	if fake.mkdirReturnsOnCall == nil {
		fake.mkdirReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mkdirReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutor) MkdirAll(arg1 string, arg2 os.FileMode) error {
	fake.mkdirAllMutex.Lock()
	ret, specificReturn := fake.mkdirAllReturnsOnCall[len(fake.mkdirAllArgsForCall)]
	fake.mkdirAllArgsForCall = append(fake.mkdirAllArgsForCall, struct {
		arg1 string
		arg2 os.FileMode
	}{arg1, arg2})
	fake.recordInvocation("MkdirAll", []interface{}{arg1, arg2})
	fake.mkdirAllMutex.Unlock()
	if fake.MkdirAllStub != nil {
		return fake.MkdirAllStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.mkdirAllReturns
	return fakeReturns.result1
}

func (fake *FakeExecutor) MkdirAllCallCount() int {
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	return len(fake.mkdirAllArgsForCall)
}

func (fake *FakeExecutor) MkdirAllCalls(stub func(string, os.FileMode) error) {
	fake.mkdirAllMutex.Lock()
	defer fake.mkdirAllMutex.Unlock()
	fake.MkdirAllStub = stub
}

func (fake *FakeExecutor) MkdirAllArgsForCall(i int) (string, os.FileMode) {
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	argsForCall := fake.mkdirAllArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeExecutor) MkdirAllReturns(result1 error) {
	fake.mkdirAllMutex.Lock()
	defer fake.mkdirAllMutex.Unlock()
	fake.MkdirAllStub = nil
	fake.mkdirAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutor) MkdirAllReturnsOnCall(i int, result1 error) {
	fake.mkdirAllMutex.Lock()
	defer fake.mkdirAllMutex.Unlock()
	fake.MkdirAllStub = nil
	if fake.mkdirAllReturnsOnCall == nil {
		fake.mkdirAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mkdirAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutor) Remove(arg1 string) error {
	fake.removeMutex.Lock()
	ret, specificReturn := fake.removeReturnsOnCall[len(fake.removeArgsForCall)]
	fake.removeArgsForCall = append(fake.removeArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Remove", []interface{}{arg1})
	fake.removeMutex.Unlock()
	if fake.RemoveStub != nil {
		return fake.RemoveStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeReturns
	return fakeReturns.result1
}

func (fake *FakeExecutor) RemoveCallCount() int {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	return len(fake.removeArgsForCall)
}

func (fake *FakeExecutor) RemoveCalls(stub func(string) error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = stub
}

func (fake *FakeExecutor) RemoveArgsForCall(i int) string {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	argsForCall := fake.removeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeExecutor) RemoveReturns(result1 error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	fake.removeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutor) RemoveReturnsOnCall(i int, result1 error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	if fake.removeReturnsOnCall == nil {
		fake.removeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutor) RemoveAll(arg1 string) error {
	fake.removeAllMutex.Lock()
	ret, specificReturn := fake.removeAllReturnsOnCall[len(fake.removeAllArgsForCall)]
	fake.removeAllArgsForCall = append(fake.removeAllArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("RemoveAll", []interface{}{arg1})
	fake.removeAllMutex.Unlock()
	if fake.RemoveAllStub != nil {
		return fake.RemoveAllStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.removeAllReturns
	return fakeReturns.result1
}

func (fake *FakeExecutor) RemoveAllCallCount() int {
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	return len(fake.removeAllArgsForCall)
}

func (fake *FakeExecutor) RemoveAllCalls(stub func(string) error) {
	fake.removeAllMutex.Lock()
	defer fake.removeAllMutex.Unlock()
	fake.RemoveAllStub = stub
}

func (fake *FakeExecutor) RemoveAllArgsForCall(i int) string {
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	argsForCall := fake.removeAllArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeExecutor) RemoveAllReturns(result1 error) {
	fake.removeAllMutex.Lock()
	defer fake.removeAllMutex.Unlock()
	fake.RemoveAllStub = nil
	fake.removeAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutor) RemoveAllReturnsOnCall(i int, result1 error) {
	fake.removeAllMutex.Lock()
	defer fake.removeAllMutex.Unlock()
	fake.RemoveAllStub = nil
	if fake.removeAllReturnsOnCall == nil {
		fake.removeAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutor) Stat(arg1 string) (os.FileInfo, error) {
	fake.statMutex.Lock()
	ret, specificReturn := fake.statReturnsOnCall[len(fake.statArgsForCall)]
	fake.statArgsForCall = append(fake.statArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Stat", []interface{}{arg1})
	fake.statMutex.Unlock()
	if fake.StatStub != nil {
		return fake.StatStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.statReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeExecutor) StatCallCount() int {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	return len(fake.statArgsForCall)
}

func (fake *FakeExecutor) StatCalls(stub func(string) (os.FileInfo, error)) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = stub
}

func (fake *FakeExecutor) StatArgsForCall(i int) string {
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	argsForCall := fake.statArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeExecutor) StatReturns(result1 os.FileInfo, result2 error) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = nil
	fake.statReturns = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutor) StatReturnsOnCall(i int, result1 os.FileInfo, result2 error) {
	fake.statMutex.Lock()
	defer fake.statMutex.Unlock()
	fake.StatStub = nil
	if fake.statReturnsOnCall == nil {
		fake.statReturnsOnCall = make(map[int]struct {
			result1 os.FileInfo
			result2 error
		})
	}
	fake.statReturnsOnCall[i] = struct {
		result1 os.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeExecutor) Symlink(arg1 string, arg2 string) error {
	fake.symlinkMutex.Lock()
	ret, specificReturn := fake.symlinkReturnsOnCall[len(fake.symlinkArgsForCall)]
	fake.symlinkArgsForCall = append(fake.symlinkArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("Symlink", []interface{}{arg1, arg2})
	fake.symlinkMutex.Unlock()
	if fake.SymlinkStub != nil {
		return fake.SymlinkStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.symlinkReturns
	return fakeReturns.result1
}

func (fake *FakeExecutor) SymlinkCallCount() int {
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	return len(fake.symlinkArgsForCall)
}

func (fake *FakeExecutor) SymlinkCalls(stub func(string, string) error) {
	fake.symlinkMutex.Lock()
	defer fake.symlinkMutex.Unlock()
	fake.SymlinkStub = stub
}

func (fake *FakeExecutor) SymlinkArgsForCall(i int) (string, string) {
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	argsForCall := fake.symlinkArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeExecutor) SymlinkReturns(result1 error) {
	fake.symlinkMutex.Lock()
	defer fake.symlinkMutex.Unlock()
	fake.SymlinkStub = nil
	fake.symlinkReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutor) SymlinkReturnsOnCall(i int, result1 error) {
	fake.symlinkMutex.Lock()
	defer fake.symlinkMutex.Unlock()
	fake.SymlinkStub = nil
	if fake.symlinkReturnsOnCall == nil {
		fake.symlinkReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.symlinkReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeExecutor) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.evalSymlinksMutex.RLock()
	defer fake.evalSymlinksMutex.RUnlock()
	fake.executeMutex.RLock()
	defer fake.executeMutex.RUnlock()
	fake.executeInteractiveMutex.RLock()
	defer fake.executeInteractiveMutex.RUnlock()
	fake.executeWithTimeoutMutex.RLock()
	defer fake.executeWithTimeoutMutex.RUnlock()
	fake.getDeviceForFileStatMutex.RLock()
	defer fake.getDeviceForFileStatMutex.RUnlock()
	fake.getGlobFilesMutex.RLock()
	defer fake.getGlobFilesMutex.RUnlock()
	fake.hostnameMutex.RLock()
	defer fake.hostnameMutex.RUnlock()
	fake.isDirMutex.RLock()
	defer fake.isDirMutex.RUnlock()
	fake.isDirEmptyMutex.RLock()
	defer fake.isDirEmptyMutex.RUnlock()
	fake.isExecutableMutex.RLock()
	defer fake.isExecutableMutex.RUnlock()
	fake.isNotExistMutex.RLock()
	defer fake.isNotExistMutex.RUnlock()
	fake.isSameFileMutex.RLock()
	defer fake.isSameFileMutex.RUnlock()
	fake.isSlinkMutex.RLock()
	defer fake.isSlinkMutex.RUnlock()
	fake.lstatMutex.RLock()
	defer fake.lstatMutex.RUnlock()
	fake.mkdirMutex.RLock()
	defer fake.mkdirMutex.RUnlock()
	fake.mkdirAllMutex.RLock()
	defer fake.mkdirAllMutex.RUnlock()
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	fake.removeAllMutex.RLock()
	defer fake.removeAllMutex.RUnlock()
	fake.statMutex.RLock()
	defer fake.statMutex.RUnlock()
	fake.symlinkMutex.RLock()
	defer fake.symlinkMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeExecutor) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ utils.Executor = new(FakeExecutor)

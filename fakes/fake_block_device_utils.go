// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/IBM/ubiquity/remote/mounter/block_device_utils"
)

type FakeBlockDeviceUtils struct {
	RescanAllStub        func(withISCSI bool) error
	rescanAllMutex       sync.RWMutex
	rescanAllArgsForCall []struct {
		withISCSI bool
	}
	rescanAllReturns struct {
		result1 error
	}
	rescanAllReturnsOnCall map[int]struct {
		result1 error
	}
	MountDeviceFlowStub        func(devicePath string, fsType string, mountPoint string) error
	mountDeviceFlowMutex       sync.RWMutex
	mountDeviceFlowArgsForCall []struct {
		devicePath string
		fsType     string
		mountPoint string
	}
	mountDeviceFlowReturns struct {
		result1 error
	}
	mountDeviceFlowReturnsOnCall map[int]struct {
		result1 error
	}
	RescanStub        func(protocol block_device_utils.Protocol) error
	rescanMutex       sync.RWMutex
	rescanArgsForCall []struct {
		protocol block_device_utils.Protocol
	}
	rescanReturns struct {
		result1 error
	}
	rescanReturnsOnCall map[int]struct {
		result1 error
	}
	ReloadMultipathStub        func() error
	reloadMultipathMutex       sync.RWMutex
	reloadMultipathArgsForCall []struct{}
	reloadMultipathReturns     struct {
		result1 error
	}
	reloadMultipathReturnsOnCall map[int]struct {
		result1 error
	}
	DiscoverStub        func(volumeWwn string) (string, error)
	discoverMutex       sync.RWMutex
	discoverArgsForCall []struct {
		volumeWwn string
	}
	discoverReturns struct {
		result1 string
		result2 error
	}
	discoverReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	CleanupStub        func(mpath string) error
	cleanupMutex       sync.RWMutex
	cleanupArgsForCall []struct {
		mpath string
	}
	cleanupReturns struct {
		result1 error
	}
	cleanupReturnsOnCall map[int]struct {
		result1 error
	}
	CheckFsStub        func(mpath string) (bool, error)
	checkFsMutex       sync.RWMutex
	checkFsArgsForCall []struct {
		mpath string
	}
	checkFsReturns struct {
		result1 bool
		result2 error
	}
	checkFsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	MakeFsStub        func(mpath string, fsType string) error
	makeFsMutex       sync.RWMutex
	makeFsArgsForCall []struct {
		mpath  string
		fsType string
	}
	makeFsReturns struct {
		result1 error
	}
	makeFsReturnsOnCall map[int]struct {
		result1 error
	}
	MountFsStub        func(mpath string, mpoint string) error
	mountFsMutex       sync.RWMutex
	mountFsArgsForCall []struct {
		mpath  string
		mpoint string
	}
	mountFsReturns struct {
		result1 error
	}
	mountFsReturnsOnCall map[int]struct {
		result1 error
	}
	UmountFsStub        func(mpoint string) error
	umountFsMutex       sync.RWMutex
	umountFsArgsForCall []struct {
		mpoint string
	}
	umountFsReturns struct {
		result1 error
	}
	umountFsReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBlockDeviceUtils) RescanAll(withISCSI bool) error {
	fake.rescanAllMutex.Lock()
	ret, specificReturn := fake.rescanAllReturnsOnCall[len(fake.rescanAllArgsForCall)]
	fake.rescanAllArgsForCall = append(fake.rescanAllArgsForCall, struct {
		withISCSI bool
	}{withISCSI})
	fake.recordInvocation("RescanAll", []interface{}{withISCSI})
	fake.rescanAllMutex.Unlock()
	if fake.RescanAllStub != nil {
		return fake.RescanAllStub(withISCSI)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.rescanAllReturns.result1
}

func (fake *FakeBlockDeviceUtils) RescanAllCallCount() int {
	fake.rescanAllMutex.RLock()
	defer fake.rescanAllMutex.RUnlock()
	return len(fake.rescanAllArgsForCall)
}

func (fake *FakeBlockDeviceUtils) RescanAllArgsForCall(i int) bool {
	fake.rescanAllMutex.RLock()
	defer fake.rescanAllMutex.RUnlock()
	return fake.rescanAllArgsForCall[i].withISCSI
}

func (fake *FakeBlockDeviceUtils) RescanAllReturns(result1 error) {
	fake.RescanAllStub = nil
	fake.rescanAllReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) RescanAllReturnsOnCall(i int, result1 error) {
	fake.RescanAllStub = nil
	if fake.rescanAllReturnsOnCall == nil {
		fake.rescanAllReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rescanAllReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) MountDeviceFlow(devicePath string, fsType string, mountPoint string) error {
	fake.mountDeviceFlowMutex.Lock()
	ret, specificReturn := fake.mountDeviceFlowReturnsOnCall[len(fake.mountDeviceFlowArgsForCall)]
	fake.mountDeviceFlowArgsForCall = append(fake.mountDeviceFlowArgsForCall, struct {
		devicePath string
		fsType     string
		mountPoint string
	}{devicePath, fsType, mountPoint})
	fake.recordInvocation("MountDeviceFlow", []interface{}{devicePath, fsType, mountPoint})
	fake.mountDeviceFlowMutex.Unlock()
	if fake.MountDeviceFlowStub != nil {
		return fake.MountDeviceFlowStub(devicePath, fsType, mountPoint)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.mountDeviceFlowReturns.result1
}

func (fake *FakeBlockDeviceUtils) MountDeviceFlowCallCount() int {
	fake.mountDeviceFlowMutex.RLock()
	defer fake.mountDeviceFlowMutex.RUnlock()
	return len(fake.mountDeviceFlowArgsForCall)
}

func (fake *FakeBlockDeviceUtils) MountDeviceFlowArgsForCall(i int) (string, string, string) {
	fake.mountDeviceFlowMutex.RLock()
	defer fake.mountDeviceFlowMutex.RUnlock()
	return fake.mountDeviceFlowArgsForCall[i].devicePath, fake.mountDeviceFlowArgsForCall[i].fsType, fake.mountDeviceFlowArgsForCall[i].mountPoint
}

func (fake *FakeBlockDeviceUtils) MountDeviceFlowReturns(result1 error) {
	fake.MountDeviceFlowStub = nil
	fake.mountDeviceFlowReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) MountDeviceFlowReturnsOnCall(i int, result1 error) {
	fake.MountDeviceFlowStub = nil
	if fake.mountDeviceFlowReturnsOnCall == nil {
		fake.mountDeviceFlowReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mountDeviceFlowReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) Rescan(protocol block_device_utils.Protocol) error {
	fake.rescanMutex.Lock()
	ret, specificReturn := fake.rescanReturnsOnCall[len(fake.rescanArgsForCall)]
	fake.rescanArgsForCall = append(fake.rescanArgsForCall, struct {
		protocol block_device_utils.Protocol
	}{protocol})
	fake.recordInvocation("Rescan", []interface{}{protocol})
	fake.rescanMutex.Unlock()
	if fake.RescanStub != nil {
		return fake.RescanStub(protocol)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.rescanReturns.result1
}

func (fake *FakeBlockDeviceUtils) RescanCallCount() int {
	fake.rescanMutex.RLock()
	defer fake.rescanMutex.RUnlock()
	return len(fake.rescanArgsForCall)
}

func (fake *FakeBlockDeviceUtils) RescanArgsForCall(i int) block_device_utils.Protocol {
	fake.rescanMutex.RLock()
	defer fake.rescanMutex.RUnlock()
	return fake.rescanArgsForCall[i].protocol
}

func (fake *FakeBlockDeviceUtils) RescanReturns(result1 error) {
	fake.RescanStub = nil
	fake.rescanReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) RescanReturnsOnCall(i int, result1 error) {
	fake.RescanStub = nil
	if fake.rescanReturnsOnCall == nil {
		fake.rescanReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rescanReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) ReloadMultipath() error {
	fake.reloadMultipathMutex.Lock()
	ret, specificReturn := fake.reloadMultipathReturnsOnCall[len(fake.reloadMultipathArgsForCall)]
	fake.reloadMultipathArgsForCall = append(fake.reloadMultipathArgsForCall, struct{}{})
	fake.recordInvocation("ReloadMultipath", []interface{}{})
	fake.reloadMultipathMutex.Unlock()
	if fake.ReloadMultipathStub != nil {
		return fake.ReloadMultipathStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.reloadMultipathReturns.result1
}

func (fake *FakeBlockDeviceUtils) ReloadMultipathCallCount() int {
	fake.reloadMultipathMutex.RLock()
	defer fake.reloadMultipathMutex.RUnlock()
	return len(fake.reloadMultipathArgsForCall)
}

func (fake *FakeBlockDeviceUtils) ReloadMultipathReturns(result1 error) {
	fake.ReloadMultipathStub = nil
	fake.reloadMultipathReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) ReloadMultipathReturnsOnCall(i int, result1 error) {
	fake.ReloadMultipathStub = nil
	if fake.reloadMultipathReturnsOnCall == nil {
		fake.reloadMultipathReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.reloadMultipathReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) Discover(volumeWwn string) (string, error) {
	fake.discoverMutex.Lock()
	ret, specificReturn := fake.discoverReturnsOnCall[len(fake.discoverArgsForCall)]
	fake.discoverArgsForCall = append(fake.discoverArgsForCall, struct {
		volumeWwn string
	}{volumeWwn})
	fake.recordInvocation("Discover", []interface{}{volumeWwn})
	fake.discoverMutex.Unlock()
	if fake.DiscoverStub != nil {
		return fake.DiscoverStub(volumeWwn)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.discoverReturns.result1, fake.discoverReturns.result2
}

func (fake *FakeBlockDeviceUtils) DiscoverCallCount() int {
	fake.discoverMutex.RLock()
	defer fake.discoverMutex.RUnlock()
	return len(fake.discoverArgsForCall)
}

func (fake *FakeBlockDeviceUtils) DiscoverArgsForCall(i int) string {
	fake.discoverMutex.RLock()
	defer fake.discoverMutex.RUnlock()
	return fake.discoverArgsForCall[i].volumeWwn
}

func (fake *FakeBlockDeviceUtils) DiscoverReturns(result1 string, result2 error) {
	fake.DiscoverStub = nil
	fake.discoverReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeBlockDeviceUtils) DiscoverReturnsOnCall(i int, result1 string, result2 error) {
	fake.DiscoverStub = nil
	if fake.discoverReturnsOnCall == nil {
		fake.discoverReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.discoverReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeBlockDeviceUtils) Cleanup(mpath string) error {
	fake.cleanupMutex.Lock()
	ret, specificReturn := fake.cleanupReturnsOnCall[len(fake.cleanupArgsForCall)]
	fake.cleanupArgsForCall = append(fake.cleanupArgsForCall, struct {
		mpath string
	}{mpath})
	fake.recordInvocation("Cleanup", []interface{}{mpath})
	fake.cleanupMutex.Unlock()
	if fake.CleanupStub != nil {
		return fake.CleanupStub(mpath)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cleanupReturns.result1
}

func (fake *FakeBlockDeviceUtils) CleanupCallCount() int {
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	return len(fake.cleanupArgsForCall)
}

func (fake *FakeBlockDeviceUtils) CleanupArgsForCall(i int) string {
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	return fake.cleanupArgsForCall[i].mpath
}

func (fake *FakeBlockDeviceUtils) CleanupReturns(result1 error) {
	fake.CleanupStub = nil
	fake.cleanupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) CleanupReturnsOnCall(i int, result1 error) {
	fake.CleanupStub = nil
	if fake.cleanupReturnsOnCall == nil {
		fake.cleanupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cleanupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) CheckFs(mpath string) (bool, error) {
	fake.checkFsMutex.Lock()
	ret, specificReturn := fake.checkFsReturnsOnCall[len(fake.checkFsArgsForCall)]
	fake.checkFsArgsForCall = append(fake.checkFsArgsForCall, struct {
		mpath string
	}{mpath})
	fake.recordInvocation("CheckFs", []interface{}{mpath})
	fake.checkFsMutex.Unlock()
	if fake.CheckFsStub != nil {
		return fake.CheckFsStub(mpath)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.checkFsReturns.result1, fake.checkFsReturns.result2
}

func (fake *FakeBlockDeviceUtils) CheckFsCallCount() int {
	fake.checkFsMutex.RLock()
	defer fake.checkFsMutex.RUnlock()
	return len(fake.checkFsArgsForCall)
}

func (fake *FakeBlockDeviceUtils) CheckFsArgsForCall(i int) string {
	fake.checkFsMutex.RLock()
	defer fake.checkFsMutex.RUnlock()
	return fake.checkFsArgsForCall[i].mpath
}

func (fake *FakeBlockDeviceUtils) CheckFsReturns(result1 bool, result2 error) {
	fake.CheckFsStub = nil
	fake.checkFsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBlockDeviceUtils) CheckFsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.CheckFsStub = nil
	if fake.checkFsReturnsOnCall == nil {
		fake.checkFsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkFsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBlockDeviceUtils) MakeFs(mpath string, fsType string) error {
	fake.makeFsMutex.Lock()
	ret, specificReturn := fake.makeFsReturnsOnCall[len(fake.makeFsArgsForCall)]
	fake.makeFsArgsForCall = append(fake.makeFsArgsForCall, struct {
		mpath  string
		fsType string
	}{mpath, fsType})
	fake.recordInvocation("MakeFs", []interface{}{mpath, fsType})
	fake.makeFsMutex.Unlock()
	if fake.MakeFsStub != nil {
		return fake.MakeFsStub(mpath, fsType)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.makeFsReturns.result1
}

func (fake *FakeBlockDeviceUtils) MakeFsCallCount() int {
	fake.makeFsMutex.RLock()
	defer fake.makeFsMutex.RUnlock()
	return len(fake.makeFsArgsForCall)
}

func (fake *FakeBlockDeviceUtils) MakeFsArgsForCall(i int) (string, string) {
	fake.makeFsMutex.RLock()
	defer fake.makeFsMutex.RUnlock()
	return fake.makeFsArgsForCall[i].mpath, fake.makeFsArgsForCall[i].fsType
}

func (fake *FakeBlockDeviceUtils) MakeFsReturns(result1 error) {
	fake.MakeFsStub = nil
	fake.makeFsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) MakeFsReturnsOnCall(i int, result1 error) {
	fake.MakeFsStub = nil
	if fake.makeFsReturnsOnCall == nil {
		fake.makeFsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.makeFsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) MountFs(mpath string, mpoint string) error {
	fake.mountFsMutex.Lock()
	ret, specificReturn := fake.mountFsReturnsOnCall[len(fake.mountFsArgsForCall)]
	fake.mountFsArgsForCall = append(fake.mountFsArgsForCall, struct {
		mpath  string
		mpoint string
	}{mpath, mpoint})
	fake.recordInvocation("MountFs", []interface{}{mpath, mpoint})
	fake.mountFsMutex.Unlock()
	if fake.MountFsStub != nil {
		return fake.MountFsStub(mpath, mpoint)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.mountFsReturns.result1
}

func (fake *FakeBlockDeviceUtils) MountFsCallCount() int {
	fake.mountFsMutex.RLock()
	defer fake.mountFsMutex.RUnlock()
	return len(fake.mountFsArgsForCall)
}

func (fake *FakeBlockDeviceUtils) MountFsArgsForCall(i int) (string, string) {
	fake.mountFsMutex.RLock()
	defer fake.mountFsMutex.RUnlock()
	return fake.mountFsArgsForCall[i].mpath, fake.mountFsArgsForCall[i].mpoint
}

func (fake *FakeBlockDeviceUtils) MountFsReturns(result1 error) {
	fake.MountFsStub = nil
	fake.mountFsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) MountFsReturnsOnCall(i int, result1 error) {
	fake.MountFsStub = nil
	if fake.mountFsReturnsOnCall == nil {
		fake.mountFsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mountFsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) UmountFs(mpoint string) error {
	fake.umountFsMutex.Lock()
	ret, specificReturn := fake.umountFsReturnsOnCall[len(fake.umountFsArgsForCall)]
	fake.umountFsArgsForCall = append(fake.umountFsArgsForCall, struct {
		mpoint string
	}{mpoint})
	fake.recordInvocation("UmountFs", []interface{}{mpoint})
	fake.umountFsMutex.Unlock()
	if fake.UmountFsStub != nil {
		return fake.UmountFsStub(mpoint)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.umountFsReturns.result1
}

func (fake *FakeBlockDeviceUtils) UmountFsCallCount() int {
	fake.umountFsMutex.RLock()
	defer fake.umountFsMutex.RUnlock()
	return len(fake.umountFsArgsForCall)
}

func (fake *FakeBlockDeviceUtils) UmountFsArgsForCall(i int) string {
	fake.umountFsMutex.RLock()
	defer fake.umountFsMutex.RUnlock()
	return fake.umountFsArgsForCall[i].mpoint
}

func (fake *FakeBlockDeviceUtils) UmountFsReturns(result1 error) {
	fake.UmountFsStub = nil
	fake.umountFsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) UmountFsReturnsOnCall(i int, result1 error) {
	fake.UmountFsStub = nil
	if fake.umountFsReturnsOnCall == nil {
		fake.umountFsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.umountFsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.rescanAllMutex.RLock()
	defer fake.rescanAllMutex.RUnlock()
	fake.mountDeviceFlowMutex.RLock()
	defer fake.mountDeviceFlowMutex.RUnlock()
	fake.rescanMutex.RLock()
	defer fake.rescanMutex.RUnlock()
	fake.reloadMultipathMutex.RLock()
	defer fake.reloadMultipathMutex.RUnlock()
	fake.discoverMutex.RLock()
	defer fake.discoverMutex.RUnlock()
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	fake.checkFsMutex.RLock()
	defer fake.checkFsMutex.RUnlock()
	fake.makeFsMutex.RLock()
	defer fake.makeFsMutex.RUnlock()
	fake.mountFsMutex.RLock()
	defer fake.mountFsMutex.RUnlock()
	fake.umountFsMutex.RLock()
	defer fake.umountFsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBlockDeviceUtils) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ block_device_utils.BlockDeviceUtils = new(FakeBlockDeviceUtils)

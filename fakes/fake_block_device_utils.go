// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/IBM/ubiquity/remote/mounter/block_device_utils"
)

type FakeBlockDeviceUtils struct {
	RescanStub        func(protocol block_device_utils.Protocol) error
	rescanMutex       sync.RWMutex
	rescanArgsForCall []struct {
		protocol block_device_utils.Protocol
	}
	rescanReturns struct {
		result1 error
	}
	rescanReturnsOnCall map[int]struct {
		result1 error
	}
	ReloadMultipathStub        func() error
	reloadMultipathMutex       sync.RWMutex
	reloadMultipathArgsForCall []struct{}
	reloadMultipathReturns     struct {
		result1 error
	}
	reloadMultipathReturnsOnCall map[int]struct {
		result1 error
	}
	DiscoverStub        func(volumeWwn string, deepDiscovery bool) (string, error)
	discoverMutex       sync.RWMutex
	discoverArgsForCall []struct {
		volumeWwn     string
		deepDiscovery bool
	}
	discoverReturns struct {
		result1 string
		result2 error
	}
	discoverReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetWwnByScsiInqStub        func(mpathOutput string, dev string) (string, error)
	getWwnByScsiInqMutex       sync.RWMutex
	getWwnByScsiInqArgsForCall []struct {
		mpathOutput string
		dev         string
	}
	getWwnByScsiInqReturns struct {
		result1 string
		result2 error
	}
	getWwnByScsiInqReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	DiscoverBySgInqStub        func(mpathOutput string, volumeWwn string) (string, error)
	discoverBySgInqMutex       sync.RWMutex
	discoverBySgInqArgsForCall []struct {
		mpathOutput string
		volumeWwn   string
	}
	discoverBySgInqReturns struct {
		result1 string
		result2 error
	}
	discoverBySgInqReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	CleanupStub        func(mpath string) error
	cleanupMutex       sync.RWMutex
	cleanupArgsForCall []struct {
		mpath string
	}
	cleanupReturns struct {
		result1 error
	}
	cleanupReturnsOnCall map[int]struct {
		result1 error
	}
	CheckFsStub        func(mpath string) (bool, error)
	checkFsMutex       sync.RWMutex
	checkFsArgsForCall []struct {
		mpath string
	}
	checkFsReturns struct {
		result1 bool
		result2 error
	}
	checkFsReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	MakeFsStub        func(mpath string, fsType string) error
	makeFsMutex       sync.RWMutex
	makeFsArgsForCall []struct {
		mpath  string
		fsType string
	}
	makeFsReturns struct {
		result1 error
	}
	makeFsReturnsOnCall map[int]struct {
		result1 error
	}
	MountFsStub        func(mpath string, mpoint string) error
	mountFsMutex       sync.RWMutex
	mountFsArgsForCall []struct {
		mpath  string
		mpoint string
	}
	mountFsReturns struct {
		result1 error
	}
	mountFsReturnsOnCall map[int]struct {
		result1 error
	}
	UmountFsStub        func(mpoint string, volumeWwn string) error
	umountFsMutex       sync.RWMutex
	umountFsArgsForCall []struct {
		mpoint    string
		volumeWwn string
	}
	umountFsReturns struct {
		result1 error
	}
	umountFsReturnsOnCall map[int]struct {
		result1 error
	}
	IsDeviceMountedStub        func(devPath string) (bool, []string, error)
	isDeviceMountedMutex       sync.RWMutex
	isDeviceMountedArgsForCall []struct {
		devPath string
	}
	isDeviceMountedReturns struct {
		result1 bool
		result2 []string
		result3 error
	}
	isDeviceMountedReturnsOnCall map[int]struct {
		result1 bool
		result2 []string
		result3 error
	}
	IsDirAMountPointStub        func(dirPath string) (bool, []string, error)
	isDirAMountPointMutex       sync.RWMutex
	isDirAMountPointArgsForCall []struct {
		dirPath string
	}
	isDirAMountPointReturns struct {
		result1 bool
		result2 []string
		result3 error
	}
	isDirAMountPointReturnsOnCall map[int]struct {
		result1 bool
		result2 []string
		result3 error
	}
	SetDmsetupStub        func(mpath string) error
	setDmsetupMutex       sync.RWMutex
	setDmsetupArgsForCall []struct {
		mpath string
	}
	setDmsetupReturns struct {
		result1 error
	}
	setDmsetupReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBlockDeviceUtils) Rescan(protocol block_device_utils.Protocol) error {
	fake.rescanMutex.Lock()
	ret, specificReturn := fake.rescanReturnsOnCall[len(fake.rescanArgsForCall)]
	fake.rescanArgsForCall = append(fake.rescanArgsForCall, struct {
		protocol block_device_utils.Protocol
	}{protocol})
	fake.recordInvocation("Rescan", []interface{}{protocol})
	fake.rescanMutex.Unlock()
	if fake.RescanStub != nil {
		return fake.RescanStub(protocol)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.rescanReturns.result1
}

func (fake *FakeBlockDeviceUtils) RescanCallCount() int {
	fake.rescanMutex.RLock()
	defer fake.rescanMutex.RUnlock()
	return len(fake.rescanArgsForCall)
}

func (fake *FakeBlockDeviceUtils) RescanArgsForCall(i int) block_device_utils.Protocol {
	fake.rescanMutex.RLock()
	defer fake.rescanMutex.RUnlock()
	return fake.rescanArgsForCall[i].protocol
}

func (fake *FakeBlockDeviceUtils) RescanReturns(result1 error) {
	fake.RescanStub = nil
	fake.rescanReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) RescanReturnsOnCall(i int, result1 error) {
	fake.RescanStub = nil
	if fake.rescanReturnsOnCall == nil {
		fake.rescanReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rescanReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) ReloadMultipath() error {
	fake.reloadMultipathMutex.Lock()
	ret, specificReturn := fake.reloadMultipathReturnsOnCall[len(fake.reloadMultipathArgsForCall)]
	fake.reloadMultipathArgsForCall = append(fake.reloadMultipathArgsForCall, struct{}{})
	fake.recordInvocation("ReloadMultipath", []interface{}{})
	fake.reloadMultipathMutex.Unlock()
	if fake.ReloadMultipathStub != nil {
		return fake.ReloadMultipathStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.reloadMultipathReturns.result1
}

func (fake *FakeBlockDeviceUtils) ReloadMultipathCallCount() int {
	fake.reloadMultipathMutex.RLock()
	defer fake.reloadMultipathMutex.RUnlock()
	return len(fake.reloadMultipathArgsForCall)
}

func (fake *FakeBlockDeviceUtils) ReloadMultipathReturns(result1 error) {
	fake.ReloadMultipathStub = nil
	fake.reloadMultipathReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) ReloadMultipathReturnsOnCall(i int, result1 error) {
	fake.ReloadMultipathStub = nil
	if fake.reloadMultipathReturnsOnCall == nil {
		fake.reloadMultipathReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.reloadMultipathReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) Discover(volumeWwn string, deepDiscovery bool) (string, error) {
	fake.discoverMutex.Lock()
	ret, specificReturn := fake.discoverReturnsOnCall[len(fake.discoverArgsForCall)]
	fake.discoverArgsForCall = append(fake.discoverArgsForCall, struct {
		volumeWwn     string
		deepDiscovery bool
	}{volumeWwn, deepDiscovery})
	fake.recordInvocation("Discover", []interface{}{volumeWwn, deepDiscovery})
	fake.discoverMutex.Unlock()
	if fake.DiscoverStub != nil {
		return fake.DiscoverStub(volumeWwn, deepDiscovery)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.discoverReturns.result1, fake.discoverReturns.result2
}

func (fake *FakeBlockDeviceUtils) DiscoverCallCount() int {
	fake.discoverMutex.RLock()
	defer fake.discoverMutex.RUnlock()
	return len(fake.discoverArgsForCall)
}

func (fake *FakeBlockDeviceUtils) DiscoverArgsForCall(i int) (string, bool) {
	fake.discoverMutex.RLock()
	defer fake.discoverMutex.RUnlock()
	return fake.discoverArgsForCall[i].volumeWwn, fake.discoverArgsForCall[i].deepDiscovery
}

func (fake *FakeBlockDeviceUtils) DiscoverReturns(result1 string, result2 error) {
	fake.DiscoverStub = nil
	fake.discoverReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeBlockDeviceUtils) DiscoverReturnsOnCall(i int, result1 string, result2 error) {
	fake.DiscoverStub = nil
	if fake.discoverReturnsOnCall == nil {
		fake.discoverReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.discoverReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeBlockDeviceUtils) GetWwnByScsiInq(mpathOutput string, dev string) (string, error) {
	fake.getWwnByScsiInqMutex.Lock()
	ret, specificReturn := fake.getWwnByScsiInqReturnsOnCall[len(fake.getWwnByScsiInqArgsForCall)]
	fake.getWwnByScsiInqArgsForCall = append(fake.getWwnByScsiInqArgsForCall, struct {
		mpathOutput string
		dev         string
	}{mpathOutput, dev})
	fake.recordInvocation("GetWwnByScsiInq", []interface{}{mpathOutput, dev})
	fake.getWwnByScsiInqMutex.Unlock()
	if fake.GetWwnByScsiInqStub != nil {
		return fake.GetWwnByScsiInqStub(mpathOutput, dev)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getWwnByScsiInqReturns.result1, fake.getWwnByScsiInqReturns.result2
}

func (fake *FakeBlockDeviceUtils) GetWwnByScsiInqCallCount() int {
	fake.getWwnByScsiInqMutex.RLock()
	defer fake.getWwnByScsiInqMutex.RUnlock()
	return len(fake.getWwnByScsiInqArgsForCall)
}

func (fake *FakeBlockDeviceUtils) GetWwnByScsiInqArgsForCall(i int) (string, string) {
	fake.getWwnByScsiInqMutex.RLock()
	defer fake.getWwnByScsiInqMutex.RUnlock()
	return fake.getWwnByScsiInqArgsForCall[i].mpathOutput, fake.getWwnByScsiInqArgsForCall[i].dev
}

func (fake *FakeBlockDeviceUtils) GetWwnByScsiInqReturns(result1 string, result2 error) {
	fake.GetWwnByScsiInqStub = nil
	fake.getWwnByScsiInqReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeBlockDeviceUtils) GetWwnByScsiInqReturnsOnCall(i int, result1 string, result2 error) {
	fake.GetWwnByScsiInqStub = nil
	if fake.getWwnByScsiInqReturnsOnCall == nil {
		fake.getWwnByScsiInqReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getWwnByScsiInqReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeBlockDeviceUtils) DiscoverBySgInq(mpathOutput string, volumeWwn string) (string, error) {
	fake.discoverBySgInqMutex.Lock()
	ret, specificReturn := fake.discoverBySgInqReturnsOnCall[len(fake.discoverBySgInqArgsForCall)]
	fake.discoverBySgInqArgsForCall = append(fake.discoverBySgInqArgsForCall, struct {
		mpathOutput string
		volumeWwn   string
	}{mpathOutput, volumeWwn})
	fake.recordInvocation("DiscoverBySgInq", []interface{}{mpathOutput, volumeWwn})
	fake.discoverBySgInqMutex.Unlock()
	if fake.DiscoverBySgInqStub != nil {
		return fake.DiscoverBySgInqStub(mpathOutput, volumeWwn)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.discoverBySgInqReturns.result1, fake.discoverBySgInqReturns.result2
}

func (fake *FakeBlockDeviceUtils) DiscoverBySgInqCallCount() int {
	fake.discoverBySgInqMutex.RLock()
	defer fake.discoverBySgInqMutex.RUnlock()
	return len(fake.discoverBySgInqArgsForCall)
}

func (fake *FakeBlockDeviceUtils) DiscoverBySgInqArgsForCall(i int) (string, string) {
	fake.discoverBySgInqMutex.RLock()
	defer fake.discoverBySgInqMutex.RUnlock()
	return fake.discoverBySgInqArgsForCall[i].mpathOutput, fake.discoverBySgInqArgsForCall[i].volumeWwn
}

func (fake *FakeBlockDeviceUtils) DiscoverBySgInqReturns(result1 string, result2 error) {
	fake.DiscoverBySgInqStub = nil
	fake.discoverBySgInqReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeBlockDeviceUtils) DiscoverBySgInqReturnsOnCall(i int, result1 string, result2 error) {
	fake.DiscoverBySgInqStub = nil
	if fake.discoverBySgInqReturnsOnCall == nil {
		fake.discoverBySgInqReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.discoverBySgInqReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeBlockDeviceUtils) Cleanup(mpath string) error {
	fake.cleanupMutex.Lock()
	ret, specificReturn := fake.cleanupReturnsOnCall[len(fake.cleanupArgsForCall)]
	fake.cleanupArgsForCall = append(fake.cleanupArgsForCall, struct {
		mpath string
	}{mpath})
	fake.recordInvocation("Cleanup", []interface{}{mpath})
	fake.cleanupMutex.Unlock()
	if fake.CleanupStub != nil {
		return fake.CleanupStub(mpath)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.cleanupReturns.result1
}

func (fake *FakeBlockDeviceUtils) CleanupCallCount() int {
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	return len(fake.cleanupArgsForCall)
}

func (fake *FakeBlockDeviceUtils) CleanupArgsForCall(i int) string {
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	return fake.cleanupArgsForCall[i].mpath
}

func (fake *FakeBlockDeviceUtils) CleanupReturns(result1 error) {
	fake.CleanupStub = nil
	fake.cleanupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) CleanupReturnsOnCall(i int, result1 error) {
	fake.CleanupStub = nil
	if fake.cleanupReturnsOnCall == nil {
		fake.cleanupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cleanupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) CheckFs(mpath string) (bool, error) {
	fake.checkFsMutex.Lock()
	ret, specificReturn := fake.checkFsReturnsOnCall[len(fake.checkFsArgsForCall)]
	fake.checkFsArgsForCall = append(fake.checkFsArgsForCall, struct {
		mpath string
	}{mpath})
	fake.recordInvocation("CheckFs", []interface{}{mpath})
	fake.checkFsMutex.Unlock()
	if fake.CheckFsStub != nil {
		return fake.CheckFsStub(mpath)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.checkFsReturns.result1, fake.checkFsReturns.result2
}

func (fake *FakeBlockDeviceUtils) CheckFsCallCount() int {
	fake.checkFsMutex.RLock()
	defer fake.checkFsMutex.RUnlock()
	return len(fake.checkFsArgsForCall)
}

func (fake *FakeBlockDeviceUtils) CheckFsArgsForCall(i int) string {
	fake.checkFsMutex.RLock()
	defer fake.checkFsMutex.RUnlock()
	return fake.checkFsArgsForCall[i].mpath
}

func (fake *FakeBlockDeviceUtils) CheckFsReturns(result1 bool, result2 error) {
	fake.CheckFsStub = nil
	fake.checkFsReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBlockDeviceUtils) CheckFsReturnsOnCall(i int, result1 bool, result2 error) {
	fake.CheckFsStub = nil
	if fake.checkFsReturnsOnCall == nil {
		fake.checkFsReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkFsReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeBlockDeviceUtils) MakeFs(mpath string, fsType string) error {
	fake.makeFsMutex.Lock()
	ret, specificReturn := fake.makeFsReturnsOnCall[len(fake.makeFsArgsForCall)]
	fake.makeFsArgsForCall = append(fake.makeFsArgsForCall, struct {
		mpath  string
		fsType string
	}{mpath, fsType})
	fake.recordInvocation("MakeFs", []interface{}{mpath, fsType})
	fake.makeFsMutex.Unlock()
	if fake.MakeFsStub != nil {
		return fake.MakeFsStub(mpath, fsType)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.makeFsReturns.result1
}

func (fake *FakeBlockDeviceUtils) MakeFsCallCount() int {
	fake.makeFsMutex.RLock()
	defer fake.makeFsMutex.RUnlock()
	return len(fake.makeFsArgsForCall)
}

func (fake *FakeBlockDeviceUtils) MakeFsArgsForCall(i int) (string, string) {
	fake.makeFsMutex.RLock()
	defer fake.makeFsMutex.RUnlock()
	return fake.makeFsArgsForCall[i].mpath, fake.makeFsArgsForCall[i].fsType
}

func (fake *FakeBlockDeviceUtils) MakeFsReturns(result1 error) {
	fake.MakeFsStub = nil
	fake.makeFsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) MakeFsReturnsOnCall(i int, result1 error) {
	fake.MakeFsStub = nil
	if fake.makeFsReturnsOnCall == nil {
		fake.makeFsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.makeFsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) MountFs(mpath string, mpoint string) error {
	fake.mountFsMutex.Lock()
	ret, specificReturn := fake.mountFsReturnsOnCall[len(fake.mountFsArgsForCall)]
	fake.mountFsArgsForCall = append(fake.mountFsArgsForCall, struct {
		mpath  string
		mpoint string
	}{mpath, mpoint})
	fake.recordInvocation("MountFs", []interface{}{mpath, mpoint})
	fake.mountFsMutex.Unlock()
	if fake.MountFsStub != nil {
		return fake.MountFsStub(mpath, mpoint)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.mountFsReturns.result1
}

func (fake *FakeBlockDeviceUtils) MountFsCallCount() int {
	fake.mountFsMutex.RLock()
	defer fake.mountFsMutex.RUnlock()
	return len(fake.mountFsArgsForCall)
}

func (fake *FakeBlockDeviceUtils) MountFsArgsForCall(i int) (string, string) {
	fake.mountFsMutex.RLock()
	defer fake.mountFsMutex.RUnlock()
	return fake.mountFsArgsForCall[i].mpath, fake.mountFsArgsForCall[i].mpoint
}

func (fake *FakeBlockDeviceUtils) MountFsReturns(result1 error) {
	fake.MountFsStub = nil
	fake.mountFsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) MountFsReturnsOnCall(i int, result1 error) {
	fake.MountFsStub = nil
	if fake.mountFsReturnsOnCall == nil {
		fake.mountFsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mountFsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) UmountFs(mpoint string, volumeWwn string) error {
	fake.umountFsMutex.Lock()
	ret, specificReturn := fake.umountFsReturnsOnCall[len(fake.umountFsArgsForCall)]
	fake.umountFsArgsForCall = append(fake.umountFsArgsForCall, struct {
		mpoint    string
		volumeWwn string
	}{mpoint, volumeWwn})
	fake.recordInvocation("UmountFs", []interface{}{mpoint, volumeWwn})
	fake.umountFsMutex.Unlock()
	if fake.UmountFsStub != nil {
		return fake.UmountFsStub(mpoint, volumeWwn)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.umountFsReturns.result1
}

func (fake *FakeBlockDeviceUtils) UmountFsCallCount() int {
	fake.umountFsMutex.RLock()
	defer fake.umountFsMutex.RUnlock()
	return len(fake.umountFsArgsForCall)
}

func (fake *FakeBlockDeviceUtils) UmountFsArgsForCall(i int) (string, string) {
	fake.umountFsMutex.RLock()
	defer fake.umountFsMutex.RUnlock()
	return fake.umountFsArgsForCall[i].mpoint, fake.umountFsArgsForCall[i].volumeWwn
}

func (fake *FakeBlockDeviceUtils) UmountFsReturns(result1 error) {
	fake.UmountFsStub = nil
	fake.umountFsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) UmountFsReturnsOnCall(i int, result1 error) {
	fake.UmountFsStub = nil
	if fake.umountFsReturnsOnCall == nil {
		fake.umountFsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.umountFsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) IsDeviceMounted(devPath string) (bool, []string, error) {
	fake.isDeviceMountedMutex.Lock()
	ret, specificReturn := fake.isDeviceMountedReturnsOnCall[len(fake.isDeviceMountedArgsForCall)]
	fake.isDeviceMountedArgsForCall = append(fake.isDeviceMountedArgsForCall, struct {
		devPath string
	}{devPath})
	fake.recordInvocation("IsDeviceMounted", []interface{}{devPath})
	fake.isDeviceMountedMutex.Unlock()
	if fake.IsDeviceMountedStub != nil {
		return fake.IsDeviceMountedStub(devPath)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.isDeviceMountedReturns.result1, fake.isDeviceMountedReturns.result2, fake.isDeviceMountedReturns.result3
}

func (fake *FakeBlockDeviceUtils) IsDeviceMountedCallCount() int {
	fake.isDeviceMountedMutex.RLock()
	defer fake.isDeviceMountedMutex.RUnlock()
	return len(fake.isDeviceMountedArgsForCall)
}

func (fake *FakeBlockDeviceUtils) IsDeviceMountedArgsForCall(i int) string {
	fake.isDeviceMountedMutex.RLock()
	defer fake.isDeviceMountedMutex.RUnlock()
	return fake.isDeviceMountedArgsForCall[i].devPath
}

func (fake *FakeBlockDeviceUtils) IsDeviceMountedReturns(result1 bool, result2 []string, result3 error) {
	fake.IsDeviceMountedStub = nil
	fake.isDeviceMountedReturns = struct {
		result1 bool
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBlockDeviceUtils) IsDeviceMountedReturnsOnCall(i int, result1 bool, result2 []string, result3 error) {
	fake.IsDeviceMountedStub = nil
	if fake.isDeviceMountedReturnsOnCall == nil {
		fake.isDeviceMountedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 []string
			result3 error
		})
	}
	fake.isDeviceMountedReturnsOnCall[i] = struct {
		result1 bool
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBlockDeviceUtils) IsDirAMountPoint(dirPath string) (bool, []string, error) {
	fake.isDirAMountPointMutex.Lock()
	ret, specificReturn := fake.isDirAMountPointReturnsOnCall[len(fake.isDirAMountPointArgsForCall)]
	fake.isDirAMountPointArgsForCall = append(fake.isDirAMountPointArgsForCall, struct {
		dirPath string
	}{dirPath})
	fake.recordInvocation("IsDirAMountPoint", []interface{}{dirPath})
	fake.isDirAMountPointMutex.Unlock()
	if fake.IsDirAMountPointStub != nil {
		return fake.IsDirAMountPointStub(dirPath)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.isDirAMountPointReturns.result1, fake.isDirAMountPointReturns.result2, fake.isDirAMountPointReturns.result3
}

func (fake *FakeBlockDeviceUtils) IsDirAMountPointCallCount() int {
	fake.isDirAMountPointMutex.RLock()
	defer fake.isDirAMountPointMutex.RUnlock()
	return len(fake.isDirAMountPointArgsForCall)
}

func (fake *FakeBlockDeviceUtils) IsDirAMountPointArgsForCall(i int) string {
	fake.isDirAMountPointMutex.RLock()
	defer fake.isDirAMountPointMutex.RUnlock()
	return fake.isDirAMountPointArgsForCall[i].dirPath
}

func (fake *FakeBlockDeviceUtils) IsDirAMountPointReturns(result1 bool, result2 []string, result3 error) {
	fake.IsDirAMountPointStub = nil
	fake.isDirAMountPointReturns = struct {
		result1 bool
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBlockDeviceUtils) IsDirAMountPointReturnsOnCall(i int, result1 bool, result2 []string, result3 error) {
	fake.IsDirAMountPointStub = nil
	if fake.isDirAMountPointReturnsOnCall == nil {
		fake.isDirAMountPointReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 []string
			result3 error
		})
	}
	fake.isDirAMountPointReturnsOnCall[i] = struct {
		result1 bool
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeBlockDeviceUtils) SetDmsetup(mpath string) error {
	fake.setDmsetupMutex.Lock()
	ret, specificReturn := fake.setDmsetupReturnsOnCall[len(fake.setDmsetupArgsForCall)]
	fake.setDmsetupArgsForCall = append(fake.setDmsetupArgsForCall, struct {
		mpath string
	}{mpath})
	fake.recordInvocation("SetDmsetup", []interface{}{mpath})
	fake.setDmsetupMutex.Unlock()
	if fake.SetDmsetupStub != nil {
		return fake.SetDmsetupStub(mpath)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setDmsetupReturns.result1
}

func (fake *FakeBlockDeviceUtils) SetDmsetupCallCount() int {
	fake.setDmsetupMutex.RLock()
	defer fake.setDmsetupMutex.RUnlock()
	return len(fake.setDmsetupArgsForCall)
}

func (fake *FakeBlockDeviceUtils) SetDmsetupArgsForCall(i int) string {
	fake.setDmsetupMutex.RLock()
	defer fake.setDmsetupMutex.RUnlock()
	return fake.setDmsetupArgsForCall[i].mpath
}

func (fake *FakeBlockDeviceUtils) SetDmsetupReturns(result1 error) {
	fake.SetDmsetupStub = nil
	fake.setDmsetupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) SetDmsetupReturnsOnCall(i int, result1 error) {
	fake.SetDmsetupStub = nil
	if fake.setDmsetupReturnsOnCall == nil {
		fake.setDmsetupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setDmsetupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBlockDeviceUtils) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.rescanMutex.RLock()
	defer fake.rescanMutex.RUnlock()
	fake.reloadMultipathMutex.RLock()
	defer fake.reloadMultipathMutex.RUnlock()
	fake.discoverMutex.RLock()
	defer fake.discoverMutex.RUnlock()
	fake.getWwnByScsiInqMutex.RLock()
	defer fake.getWwnByScsiInqMutex.RUnlock()
	fake.discoverBySgInqMutex.RLock()
	defer fake.discoverBySgInqMutex.RUnlock()
	fake.cleanupMutex.RLock()
	defer fake.cleanupMutex.RUnlock()
	fake.checkFsMutex.RLock()
	defer fake.checkFsMutex.RUnlock()
	fake.makeFsMutex.RLock()
	defer fake.makeFsMutex.RUnlock()
	fake.mountFsMutex.RLock()
	defer fake.mountFsMutex.RUnlock()
	fake.umountFsMutex.RLock()
	defer fake.umountFsMutex.RUnlock()
	fake.isDeviceMountedMutex.RLock()
	defer fake.isDeviceMountedMutex.RUnlock()
	fake.isDirAMountPointMutex.RLock()
	defer fake.isDirAMountPointMutex.RUnlock()
	fake.setDmsetupMutex.RLock()
	defer fake.setDmsetupMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBlockDeviceUtils) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ block_device_utils.BlockDeviceUtils = new(FakeBlockDeviceUtils)
